            self.out.append(f"启动失败：{e}")

class _PayloadExtractDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("payload.bin ��ȡ")
        self.resize(700, 500)
        self._worker = None
        self._thread = None
        
        layout = QVBoxLayout(self)
        
        # ģʽѡ��
        mode_group = QWidget()
        mode_layout = QHBoxLayout(mode_group)
        mode_layout.setContentsMargins(0, 0, 0, 0)
        self.mode_local = QCheckBox("�����ļ�")
        self.mode_local.setChecked(True)
        self.mode_online = QCheckBox("���� URL")
        mode_layout.addWidget(QLabel("��ȡģʽ:"))
        mode_layout.addWidget(self.mode_local)
        mode_layout.addWidget(self.mode_online)
        mode_layout.addStretch(1)
        layout.addWidget(mode_group)
        
        # �����ļ�����
        self.local_widget = QWidget()
        local_layout = QHBoxLayout(self.local_widget)
        local_layout.setContentsMargins(0, 0, 0, 0)
        self.local_edit = QLineEdit()
        self.local_edit.setPlaceholderText("ѡ�� payload.bin ����� payload.bin �� ZIP �ļ�")
        btn_browse = QPushButton("���...")
        btn_browse.clicked.connect(self._browse_local)
        local_layout.addWidget(QLabel("�ļ�·��:"))
        local_layout.addWidget(self.local_edit)
        local_layout.addWidget(btn_browse)
        layout.addWidget(self.local_widget)
        
        # ���� URL ����
        self.online_widget = QWidget()
        online_layout = QHBoxLayout(self.online_widget)
        online_layout.setContentsMargins(0, 0, 0, 0)
        self.url_edit = QLineEdit()
        self.url_edit.setPlaceholderText("���� OTA ���°� URL������ payload.bin �� ZIP��")
        online_layout.addWidget(QLabel("URL:"))
        online_layout.addWidget(self.url_edit)
        layout.addWidget(self.online_widget)
        self.online_widget.setVisible(False)
        
        # ����ѡ��
        partition_group = QWidget()
        partition_layout = QVBoxLayout(partition_group)
        partition_layout.setContentsMargins(0, 0, 0, 0)
        partition_label = QLabel("Ҫ��ȡ�ķ����������ȡȫ����:")
        self.partition_edit = QLineEdit()
        self.partition_edit.setPlaceholderText("����: boot,vendor,system �������ȡȫ��")
        partition_layout.addWidget(partition_label)
        partition_layout.addWidget(self.partition_edit)
        layout.addWidget(partition_group)
        
        # ���Ŀ¼
        out_group = QWidget()
        out_layout = QHBoxLayout(out_group)
        out_layout.setContentsMargins(0, 0, 0, 0)
        self.out_edit = QLineEdit()
        self.out_edit.setPlaceholderText("ѡ�����Ŀ¼")
        btn_out = QPushButton("���...")
        btn_out.clicked.connect(self._browse_output)
        out_layout.addWidget(QLabel("���Ŀ¼:"))
        out_layout.addWidget(self.out_edit)
        out_layout.addWidget(btn_out)
        layout.addWidget(out_group)
        
        # ������ť
        btn_layout = QHBoxLayout()
        self.run_btn = QPushButton("��ʼ��ȡ")
        self.run_btn.clicked.connect(self._run_extract)
        self.cancel_btn = QPushButton("ȡ��")
        self.cancel_btn.clicked.connect(self._cancel)
        self.cancel_btn.setEnabled(False)
        btn_layout.addStretch(1)
        btn_layout.addWidget(self.run_btn)
        btn_layout.addWidget(self.cancel_btn)
        layout.addLayout(btn_layout)
        
        # ��־���
        self.log = QTextEdit()
        self.log.setReadOnly(True)
        layout.addWidget(self.log)
        
        # �ź�����
        self.mode_local.toggled.connect(self._on_mode_changed)
        self.mode_online.toggled.connect(self._on_mode_changed)
    
    def _on_mode_changed(self):
        if self.mode_local.isChecked():
            self.mode_online.setChecked(False)
            self.local_widget.setVisible(True)
            self.online_widget.setVisible(False)
        elif self.mode_online.isChecked():
            self.mode_local.setChecked(False)
            self.local_widget.setVisible(False)
            self.online_widget.setVisible(True)
    
    def _browse_local(self):
        path, _ = QFileDialog.getOpenFileName(
            self, "ѡ���ļ�", "", 
            "Payload �ļ� (payload.bin *.zip);;�����ļ� (*.*)"
        )
        if path:
            self.local_edit.setText(path)
    
    def _browse_output(self):
        path = QFileDialog.getExistingDirectory(self, "ѡ�����Ŀ¼")
        if path:
            self.out_edit.setText(path)
    
    def _run_extract(self):
        # ��֤����
        if self.mode_local.isChecked():
            source = self.local_edit.text().strip()
            if not source or not os.path.exists(source):
                QMessageBox.warning(self, "��ʾ", "��ѡ����Ч���ļ�")
                return
        else:
            source = self.url_edit.text().strip()
            if not source or not source.startswith('http'):
                QMessageBox.warning(self, "��ʾ", "��������Ч�� HTTP/HTTPS URL")
                return
        
        out_dir = self.out_edit.text().strip()
        if not out_dir:
            QMessageBox.warning(self, "��ʾ", "��ѡ�����Ŀ¼")
            return
        
        os.makedirs(out_dir, exist_ok=True)
        
        partitions = self.partition_edit.text().strip()
        
        # ���ð�ť
        self.run_btn.setEnabled(False)
        self.cancel_btn.setEnabled(True)
        self.log.clear()
        self.log.append(f"��ʼ��ȡ...")
        self.log.append(f"Դ: {source}")
        self.log.append(f"���: {out_dir}")
        if partitions:
            self.log.append(f"����: {partitions}")
        else:
            self.log.append("����: ȫ��")
        self.log.append("")
        
        # ���������߳�
        self._thread = QThread(self)
        self._worker = _PayloadWorker(source, out_dir, partitions)
        self._worker.moveToThread(self._thread)
        
        self._thread.started.connect(self._worker.run)
        self._worker.log.connect(self._on_log)
        self._worker.finished.connect(self._on_finished)
        self._worker.error.connect(self._on_error)
        
        self._thread.start()
    
    def _cancel(self):
        if self._worker:
            self._worker.stop()
        self.log.append("\n�û�ȡ������")
        self._cleanup()
    
    def _on_log(self, msg):
        self.log.append(msg)
    
    def _on_finished(self):
        self.log.append("\n ��ȡ��ɣ�")
        self._cleanup()
    
    def _on_error(self, error):
        self.log.append(f"\n ����: {error}")
        self._cleanup()
    
    def _cleanup(self):
        if self._thread and self._thread.isRunning():
            self._thread.quit()
            self._thread.wait(2000)
        self._thread = None
        self._worker = None
        self.run_btn.setEnabled(True)
        self.cancel_btn.setEnabled(False)
    
    def closeEvent(self, event):
        if self._thread and self._thread.isRunning():
            reply = QMessageBox.question(
                self, "ȷ��", "��ȡ���ڽ����У�ȷ��Ҫ�ر���",
                QMessageBox.Yes | QMessageBox.No
            )
            if reply == QMessageBox.No:
                event.ignore()
                return
            if self._worker:
                self._worker.stop()
        self._cleanup()
        super().closeEvent(event)


class _PayloadWorker(QObject):
    log = Signal(str)
    finished = Signal()
    error = Signal(str)
    
    def __init__(self, source, output_dir, partitions):
        super().__init__()
        self.source = source
        self.output_dir = output_dir
        self.partitions = partitions
        self._stop = False
    
    def stop(self):
        self._stop = True
    
    def run(self):
        try:
            # ��������
            cmd = ['python', '-m', 'payload_dumper']
            
            # ��ӷ�������
            if self.partitions:
                cmd.extend(['--partitions', self.partitions])
            
            # ������Ŀ¼
            cmd.extend(['--out', self.output_dir])
            
            # ���Դ�ļ�/URL
            cmd.append(self.source)
            
            self.log.emit(f"ִ������: {' '.join(cmd)}")
            self.log.emit("")
            
            # ִ������
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                encoding='utf-8',
                errors='replace'
            )
            
            # ʵʱ�����־
            while True:
                if self._stop:
                    process.terminate()
                    return
                
                line = process.stdout.readline()
                if not line and process.poll() is not None:
                    break
                
                if line:
                    self.log.emit(line.rstrip())
            
            # ����˳���
            returncode = process.wait()
            if returncode == 0:
                self.finished.emit()
            else:
                self.error.emit(f"�����˳���: {returncode}")
                
        except Exception as e:
            self.error.emit(str(e))
